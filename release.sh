#!/usr/bin/env bash
set -euo pipefail

# Requirements
command -v git >/dev/null || { echo "❌ git not found"; exit 1; }
command -v gh  >/dev/null || { echo "❌ gh (GitHub CLI) not found"; exit 1; }

# Must be inside a git repo
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "❌ Not a git repo"; exit 1; }

# Fail if dirty
if [[ -n $(git status --porcelain) ]]; then
  echo "❌ Working tree is dirty. Commit or stash first."
  exit 1
fi

# Ensure gh auth works
gh auth status >/dev/null 2>&1 || { echo "❌ gh not authenticated. Run: gh auth login"; exit 1; }

# Current branch
BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Push branch (no-op if up-to-date)
git push -u origin "$BRANCH"

# Determine latest semver tag vX.Y.Z (fallback to v0.0.0 if none)
LATEST_TAG=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n 1 || true)
if [[ -z "${LATEST_TAG:-}" ]]; then
  LATEST_TAG="v0.0.0"
fi

if [[ ! "$LATEST_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
  echo "❌ Latest tag '$LATEST_TAG' does not match vX.Y.Z"
  exit 1
fi

VERSION=${LATEST_TAG#v}
IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

PATCH=$((PATCH + 1))
NEW_TAG="v$MAJOR.$MINOR.$PATCH"

echo "Latest tag: $LATEST_TAG"
echo "New tag:    $NEW_TAG"

# Create and push tag
git tag "$NEW_TAG"
git push origin "$NEW_TAG"

# Create GitHub Release (with autogenerated notes)
gh release create "$NEW_TAG" \
  --title "$NEW_TAG" \
  --generate-notes

echo "✅ Tagged + released: $NEW_TAG"
